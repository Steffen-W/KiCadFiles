name: Auto Version Tag

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.9', '3.12']

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e ".[dev]"

    - name: Run code quality checks
      run: |
        echo "üîç Running code quality checks..."
        black --check kicadfiles/
        isort --check-only kicadfiles/
        flake8 kicadfiles/
        mypy kicadfiles/
        pyright kicadfiles/

    - name: Run tests
      run: |
        echo "üß™ Running tests..."
        pytest tests/ -v --tb=short

  create-version-tag:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    permissions:
      contents: write
      packages: write
      pages: write
      id-token: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get latest tag
      id: latest_tag
      run: |
        # Get the latest tag, default to v1.0.0 if no tags exist
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v1.0.0")
        echo "latest_tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"
        echo "Latest tag: $LATEST_TAG"

    - name: Generate new version
      id: new_version
      run: |
        LATEST_TAG="${{ steps.latest_tag.outputs.latest_tag }}"

        # Remove 'v' prefix and split version
        VERSION=${LATEST_TAG#v}
        IFS='.' read -r major minor patch <<< "$VERSION"

        # Increment patch version
        NEW_PATCH=$((patch + 1))
        NEW_VERSION="$major.$minor.$NEW_PATCH"
        NEW_TAG="v$NEW_VERSION"

        echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        echo "new_tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
        echo "New version: $NEW_TAG"

    - name: Check if tag already exists
      id: tag_exists
      run: |
        NEW_TAG="${{ steps.new_version.outputs.new_tag }}"
        if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
          echo "exists=true" >> "$GITHUB_OUTPUT"
          echo "Tag $NEW_TAG already exists"
        else
          echo "exists=false" >> "$GITHUB_OUTPUT"
          echo "Tag $NEW_TAG does not exist"
        fi

    - name: Create and push new tag
      if: steps.tag_exists.outputs.exists == 'false'
      run: |
        NEW_TAG="${{ steps.new_version.outputs.new_tag }}"
        NEW_VERSION="${{ steps.new_version.outputs.new_version }}"

        # Create annotated tag with current commit
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag -a "$NEW_TAG" -m "üè∑Ô∏è Auto-generated version $NEW_VERSION"
        git push origin "$NEW_TAG"

        echo "‚úÖ Created and pushed tag: $NEW_TAG"

    - name: Build Sphinx Documentation
      if: steps.tag_exists.outputs.exists == 'false'
      run: |
        echo "üìö Building documentation with Sphinx..."
        pip install sphinx sphinx-rtd-theme

        # Check if docs directory exists, create if not
        if [ ! -d "docs" ]; then
          mkdir docs
          cd docs
          sphinx-quickstart -q --sep --project="KiCadFiles" --author="GitHub Actions" --release="${{ steps.new_version.outputs.new_version }}" --language="en" --makefile --batchfile .
          cd ..
        fi

        # Build documentation
        cd docs
        make html
        cd ..

        echo "‚úÖ Documentation built successfully"

    - name: Deploy Documentation to GitHub Pages
      if: steps.tag_exists.outputs.exists == 'false'
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs/_build/html
        destination_dir: ${{ steps.new_version.outputs.new_version }}

    - name: Create GitHub Release
      if: steps.tag_exists.outputs.exists == 'false'
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.new_version.outputs.new_tag }}
        release_name: Release ${{ steps.new_version.outputs.new_version }}
        body: |
          ü§ñ Automated release for version ${{ steps.new_version.outputs.new_version }}

          **Changes:**
          - Auto-incremented version from ${{ steps.latest_tag.outputs.latest_tag }} to ${{ steps.new_version.outputs.new_tag }}

          Generated from commit: ${{ github.sha }}
        draft: false
        prerelease: false